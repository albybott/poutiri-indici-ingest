#!/usr/bin/env tsx

/**
 * Generate missing schema files for entities that don't have them yet
 * Based on the data extract specification
 * Usage: pnpm tsx src/services/raw-loader/scripts/generate-missing-schemas.ts
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Column definitions from the data extract specification
const entityColumns: Record<string, string[]> = {
  appointments: [
    "AppointmentID",
    "PatientID",
    "AppointmentType",
    "AppointmentStatus",
    "ScheduleDate",
    "Notes",
    "Arrived",
    "WaitingForpayment",
    "AppointmentCompleted",
    "ConsultTime",
    "Booked",
    "MedTechID",
    "InsertedAt",
    "InsertedBy",
    "UpdatedAt",
    "UpdatedBy",
    "Practice",
    "PracticeID",
    "ProviderID",
    "IsActive",
    "IsDeleted",
    "Provider",
    "PermanentAddressLatitude",
    "PermanentAddressLongitude",
    "PracticeLocationID",
    "LocationName",
    "ReasonforVisit",
    "StatusGroup",
    "Duration",
    "AppointmentOutComeID",
    "AppointmentOutCome",
    "AppointmentTypeID",
    "BookingSourceID",
    "BookingSource",
    "ConsultEndTime",
    "ConsultStartTime",
    "ConsultTimerStatusID",
    "Description",
    "EndTime",
    "GeneratedTime",
    "GPQueueTime",
    "IsArrived",
    "IsConsultParked",
    "IsDummy",
    "LastAppointmentStatusDate",
    "LastAppointmentStatusID",
    "CancelReason",
    "ParkedReason",
    "PriorityID",
    "ArrivedTime",
    "CancelledTime",
    "NotArrivedTime",
    "NurseQueueTime",
    "OnHoldTime",
    "ReadOnlyTime",
    "SelfAssessmentCompletedTime",
    "SelfAssessmentQueueTime",
    "StartTime",
    "TriageQueueTime",
    "VirtualQueueTime",
    "IsConfidential",
    "IsConsenttoShare",
    "PerOrgID",
    "LoadedDateTime",
  ],
  immunisation: [
    "AppointmentImmunisationID",
    "PatientID",
    "AppointmentID",
    "PatientScheduleID",
    "VaccineID",
    "VaccineName",
    "VaccineCode",
    "Dose",
    "DoseNumber",
    "AdministrationSiteID",
    "AdministrationSite",
    "RouteID",
    "Route",
    "BatchNumber",
    "ExpiryDate",
    "ImmunisationStatusID",
    "ImmunisationStatus",
    "VaccineOutComeID",
    "VaccineOutCome",
    "IsNIRAck",
    "Reason",
    "ProviderID",
    "Provider",
    "Comments",
    "AdministrationTime",
    "VaccineIndicationID",
    "VaccineIndication",
    "VaccineIndicationCode",
    "NeedleLength",
    "HasDiluent",
    "DiluentBatchNo",
    "DiluentExpiryDate",
    "IsConfidential",
    "CostingCodeID",
    "CostingCode",
    "BrandID",
    "Brand",
    "IsActive",
    "IsDeleted",
    "InsertedByID",
    "InsertedBy",
    "UpdatedByID",
    "UpdatedBy",
    "InsertedAt",
    "UpdatedAt",
    "IsParked",
    "MedTechID",
    "PracticeID",
    "Practice",
    "IsAutoBill",
    "VaccinatorID",
    "Vaccinator",
    "UserLoggingID",
    "LoggingUserName",
    "NIRSentDate",
    "ShowOnPortal",
    "VaccinatorCode",
    "PermanentAddressLatitude",
    "PermanentAddressLongitude",
    "PracticeLocationID",
    "LocationName",
    "VaccineGroupID",
    "VaccineGroup",
    "PerOrgId",
    "LoadedDateTime",
  ],
  medicine: [
    "MedicineID",
    "MedicineName",
    "MedicineShortName",
    "SCTID",
    "Type",
    "PharmaCode",
    "IsActive",
    "IsDeleted",
    "PerOrgId",
    "PracticeID",
    "LoadedDateTime",
  ],
  patients: [
    "PatientID",
    "NHINumber",
    "IsNHIValidate",
    "Title",
    "FirstName",
    "MiddleName",
    "FamilyName",
    "FullName",
    "PreferredName",
    "OtherMaidenName",
    "MaritalStatusID",
    "MaritalStatus",
    "GenderID",
    "Gender",
    "DOB",
    "Age",
    "AgeType",
    "AgeGroup",
    "IsAlive",
    "DeathDate",
    "DOBSource",
    "PicturePath",
    "ConsentedtoShare",
    "PlaceofBirth",
    "CountryofBirthID",
    "CountryOfBirth",
    "CellNumber",
    "DayPhone",
    "NightPhone",
    "Email",
    "SecondaryEmail",
    "PreferredContactMethod",
    "ConsentTextMessaging",
    "IsPortalUser",
    "IsActive",
    "IsDeleted",
    "InsertedBy",
    "UpdatedBy",
    "InsertedAt",
    "UpdatedAt",
    "Notes",
    "IsGenderSelfIdentified",
    "SexRelatedGender",
    "IsWorkedVisaRequired",
    "Balance",
    "MedTechBalance",
    "MedTechDATELASTPAY",
    "MedTechDATELASTSTMT",
    "RegisterStatusID",
    "RegisterStatus",
    "MedTechNOK",
    "PracticeName",
    "CalculatedBalance",
    "LastStatementDate",
    "LastInvoiceDate",
    "LastPaymentDate",
    "ProviderName",
    "ChartNumber",
    "Extention",
    "PracticeRemarks",
    "IsInsured",
    "InsuredRemarks",
    "SmokingType",
    "AccountHolder",
    "AccountHolderEmployer",
    "IsCommunityServiceCard",
    "CommunityServiceCardNo",
    "CommunityServiceCardExipryDate",
    "CommunityServiceCardSighted",
    "IsHealthCard",
    "HealthCardNo",
    "HealthCardExpiryDate",
    "HealthCardSighted",
    "WINZ",
    "IsTransferOfRecords",
    "TransferofRecordsRemarks",
    "EnrolmentType",
    "EnrolmentStatusID",
    "EnrolmentStatus",
    "EnrolmentDate",
    "EnrolmentMethod",
    "EnrolmentVerifier",
    "FundingStatusID",
    "FundingStatus",
    "RejectionReason",
    "FundingFrom",
    "FundingTo",
    "AccountGroup",
    "GMSCode",
    "ResidentialStatus",
    "IsNKA",
    "IsHighCare",
    "HighCareReason",
    "IsCarePlan",
    "IsNewRegisteration",
    "IsOptOff",
    "IsBPGraph",
    "IsBMIGraph",
    "IsINRGraph",
    "IsHbA1cGraph",
    "ASRMarkStatus",
    "IsHeightGraph",
    "IsWeightGraph",
    "IsHcGraph",
    "NESStatus",
    "NESComments",
    "MedTechBalanceDate",
    "IsHeartRate",
    "IsPremature",
    "PrematureWeek",
    "PatientPHOID",
    "ConsultUpdatedAt",
    "Occupation",
    "EmergencyContact",
    "EmergencyContactName",
    "SecondaryContact",
    "SecondaryContactName",
    "ProviderID",
    "PracticeID",
    "PortalRegistrationStatus",
    "RegistrationDate",
    "MedTechID",
    "PermanentAddressHouseNumber",
    "PermanentAddressBuildingNumber",
    "PermanentAddressStreetNumber",
    "PermanentAddressSuburbTownID",
    "PermanentAddressSuburb",
    "PermanentAddressCityAreaID",
    "PermanentAddressCity",
    "PermanentAddressPostalCode",
    "PermanentAddressLatitude",
    "PermanentAddressLongitude",
    "PermanentAddressCountryID",
    "PermanentAddressCountry",
    "PermanentAddress",
    "PermanentAddressDHBCode",
    "PermanentAddressDomicileCode",
    "PermanentAddressDeprivationQuintile",
    "PermanentAddressDeprivationDecile",
    "PermanentAddressMeshblock",
    "PermanentAddressMatchScore",
    "PermanentAddressUncertaintyCode",
    "TemporaryAddress",
    "PostalAddressHouseNumber",
    "PostalAddressBuildingNumber",
    "PostalAddressStreetNumber",
    "PostalAddressSuburbTownID",
    "PostalAddressSuburb",
    "PostalAddressCityAreaID",
    "PostalAddressCity",
    "PostalAddressPostalCode",
    "PostalAddressLatitude",
    "PostalAddressLongitude",
    "PostalAddressCountryID",
    "PostalAddressCountry",
    "PostalAddress",
    "PostalAddressDHBCode",
    "PostalAddressDomicileCode",
    "PostalAddressDeprivationQuintile",
    "PostalAddressDeprivationDecile",
    "PostalAddressMeshblock",
    "PostalAddressMatchScore",
    "PostalAddressUncertaintyCode",
    "EthnicityID",
    "Ethnicity",
    "ETHCODE",
    "ETHCODE2",
    "SecondaryEthnicityID",
    "SecondaryEthnicity",
    "ETHCODE3",
    "OtherEthnicityID",
    "OtherEthnicity",
    "EnrolmentID",
    "PHOName",
    "EnrolmentExpiryDate",
    "IsConsentToShare",
    "IsWorkVisa",
    "WorkVisaStartDate",
    "WorkVisaExpiryDate",
    "EnrolmentQuarter",
    "PracticeLocation",
    "AccountHolderTypeID",
    "PatientType",
    "BreastScreenID",
    "BreastScreen",
    "IsPregnant",
    "ApplyCharges",
    "IncludeInPrint",
    "IsCareplus",
    "CarePlusStartDate",
    "CarePlusEnddate",
    "CarePlusLincStatusID",
    "CarePlusLincStatus",
    "NHIStatusID",
    "NHIStatus",
    "PerOrgId",
    "LoadedDateTime",
    "AccountHolderProfileID",
    "ComunityServiceEffectiveDate",
    "DefaultGPMCNo",
    "DefaultGPName",
    "DefaultPracticeEDI",
    "DefaultPracticeName",
    "EnrolmentEndDate",
    "IsCapitated",
    "IsConsentAutoReminderTextMessaging",
    "IsConsentForExperienceSurvey",
    "IsConsentToImportClinicalRecords",
    "IsConsentToPrivateEmailAddress",
    "IsConsentToShareClinicalRecords",
    "IsConsentToShareHealth1",
    "IsConsentToShareMyRecordOnSEHR",
    "IsConsentToSharePHODataCollection",
    "IsIncludeAccountFee",
    "IsIncludeStatementFee",
    "IsLinkedCSCExists",
    "IsTestRecord",
    "PharmacyID",
    "ResidentialStatusID",
    "VisaExpiry",
  ],
  "practice-info": [
    "PracticeID",
    "PracticeName",
    "PracticeCategory",
    "PracticeSpeciality",
    "PHO",
    "OrganizationType",
    "OrgShortName",
    "OrgCode",
    "EDIAccount",
    "LegalEntityTitle",
    "LegalStatus",
    "IncorporationNumber",
    "LegalDate",
    "Comments",
    "Formula",
    "OwnershipModel",
    "Rural",
    "PrimaryPhone",
    "SecondaryPhone",
    "OtherPhone",
    "PrimaryEmail",
    "SecondaryEmail",
    "OtherEmail",
    "Pager",
    "Fax1",
    "Fax2",
    "HealthFacilityNo",
    "HPIFacilityNo",
    "HPIFacilityExt",
    "HPIOrganizationID",
    "HPIOrganizationExt",
    "GSTNo",
    "ACCNo",
    "BankAccountNo",
    "MOHSendingPracticeID",
    "AfterHoursNumber",
    "EmergencyNumber",
    "IsActive",
    "IsDeleted",
    "PerOrgID",
    "LoadedDateTime",
  ],
  providers: [
    "ProviderID",
    "PracticeID",
    "NHINumber",
    "IsNHIValidate",
    "Title",
    "FirstName",
    "MiddleName",
    "FamilyName",
    "FullName",
    "PreferredName",
    "OtherMaidenName",
    "MaritalStatus",
    "Gender",
    "DOB",
    "Age",
    "AgeType",
    "AgeGroup",
    "IsAlive",
    "DeathDate",
    "DOBSource",
    "PicturePath",
    "ConsentedtoShare",
    "PlaceofBirth",
    "CountryOfBirth",
    "CellNumber",
    "DayPhone",
    "NightPhone",
    "Email",
    "SecondaryEmail",
    "PreferredContactMethod",
    "ConsentTextMessaging",
    "IsPortalUser",
    "IsActive",
    "IsDeleted",
    "InsertedBy",
    "UpdatedBy",
    "InsertedAt",
    "UpdatedAt",
    "IsSameAddress",
    "Notes",
    "IsGenderSelfIdentified",
    "SexRelatedGender",
    "IsWorkedVisaRequired",
    "Balance",
    "RegisterStatus",
    "MedTechNOK",
    "PracticeName",
    "CalculatedBalance",
    "PermanentAddress",
    "DeprivationQuintile",
    "UncertaintyCode",
    "PostalAddress",
    "TemporaryAddress",
    "City",
    "Suburb",
    "PortalRegistrationStatus",
    "Ethnicity",
    "AffiliationID",
    "Affiliation",
    "AffiliationCode",
    "NZMCNO",
    "NPINo",
    "HBLMatPayeeNo",
    "HBLMatAgreeNo",
    "HPacMatAgreeNo",
    "HPacMatAgreeVer",
    "HBLPayeeNo",
    "HBLGPAgreeNo",
    "HBLGPAgreeVer",
    "AccreditationNo",
    "PHOContractNo",
    "PHOContractVer",
    "GroupID",
    "GroupName",
    "ACCProviderCode",
    "HealthFacilityNo",
    "HPINo",
    "UnloadRef",
    "ACCProviderNo",
    "ACCVendorID",
    "PinPanNo",
    "MemberNo",
    "RHAPayeeNo",
    "BudgetNo",
    "IPA",
    "RegisterationNo",
    "LabNo",
    "LabTestsDrID",
    "ColorCode",
    "IsDoctor",
    "ACC45Prefix",
    "NextACC45No",
    "MaximumACC45No",
    "AITCPrefix",
    "NextAITCNo",
    "MaximumAITCNo",
    "ARC18NextACCFormNo",
    "M45Prefix",
    "NextM45No",
    "MaximumM45No",
    "IsNZFAvoid",
    "IsNZFAdjust",
    "IsNZFInformation",
    "IsNZFNoAction",
    "IsNZFMonitor",
    "ProviderCode",
    "GenericProfileTypeID",
    "CurrentAppointmentID",
    "SureMedUserName",
    "IsInvoicingDiary",
    "IsGP2GP",
    "FromDatePractice",
    "APCExpiryDate",
    "MPSExpiryDate",
    "APCName",
    "PracticeLocation",
    "UserRole",
    "ProviderPermanentAddressLatitude",
    "ProviderPermanentAddressLongitude",
    "PerOrgId",
    "LoadedDateTime",
  ],
  vaccine: [
    "VaccineID",
    "VaccineCode",
    "VaccineName",
    "LongDescription",
    "IsActive",
    "IsDeleted",
    "CodingSystem",
    "GenderID",
    "Gender",
    "IsNIR",
    "PerOrgId",
    "PracticeID",
    "LoadedDateTime",
  ],
  allergies: [
    "AllergyID",
    "AppointmentID",
    "AllergyTypeID",
    "AllergyType",
    "OnsetDate",
    "DeactivationReason",
    "MedicineID",
    "Medicine",
    "ReactionID",
    "Reactions",
    "ReactionTypeID",
    "ReactionType",
    "SeverityID",
    "Severity",
    "ReactionNotes",
    "IsActive",
    "IsDeleted",
    "InsertedByID",
    "InsertedBy",
    "UpdatedByID",
    "UpdatedBy",
    "InsertedAt",
    "UpdatedAt",
    "PatientID",
    "Patient",
    "IsConfidential",
    "PracticeID",
    "Practice",
    "MGENCODE",
    "MCLACODE",
    "MedTechID",
    "MedicineClassificationID",
    "AllergyCategoryID",
    "AllergyCategory",
    "Comment",
    "SubstanceTypeID",
    "SubstanceType",
    "FavouriteSubstanceID",
    "FavouriteSubstance",
    "DiseaseID",
    "Disease",
    "OtherSubstance",
    "MedicineTypeID",
    "MedicineType",
    "UserLoggingID",
    "LoggingUserName",
    "ShowOnPortal",
    "WarningType",
    "ROWINACTIVE",
    "IsReviewed",
    "ProviderID",
    "Provider",
    "PracticeLocationID",
    "LocationName",
    "PerOrgID",
    "LoadedDateTime",
  ],
  appointment_medications: [
    "MedicationID",
    "AppointmentID",
    "PatientID",
    "SCTID",
    "MedicineID",
    "MedicineName",
    "Strength",
    "Form",
    "Take",
    "Frequency",
    "DAILYFREQ",
    "Route",
    "Duration",
    "DurationType",
    "StartDate",
    "EndDate",
    "StopDate",
    "Repeats",
    "SAStatus",
    "SANumber",
    "ExpiryDate",
    "SubsidyAmount",
    "Price",
    "ProviderID",
    "Provider",
    "TaskID",
    "Directions",
    "IsConfidential",
    "IsLongTerm",
    "IsPrescribedExternally",
    "IsStopped",
    "IsHighlighted",
    "IsPracticeinAdmin",
    "IsTrial",
    "StoppedReason",
    "MedicationStopReason",
    "RxSCID",
    "RxDate",
    "RxStatus",
    "IsDispense",
    "PrintedBy",
    "PrintedAt",
    "Comments",
    "IsActive",
    "IsDeleted",
    "InsertedBy",
    "UpdatedBy",
    "InsertedAt",
    "UpdatedAt",
    "MedTechID",
    "IsMapped",
    "MedTechDrugCode",
    "MedTechGenericName",
    "PracticeID",
    "PrescibedExternlayID",
    "PrescibedExternlayDesc",
    "Quantity",
    "IsGenericSubstitution",
    "IsFrequentDispensed",
    "InitialDispensePeriod",
    "InitialDispensePeriodType",
    "TrialPeriod",
    "TrialType",
    "IsSpecalistRecomended",
    "SpecalistName",
    "RecomendationDate",
    "IsEndorsementCriteria",
    "IsProviderEligibleCoPayment",
    "UserLoggingID",
    "IsOverride",
    "OverrideReason",
    "IsTaskGenerated",
    "ShowOnPortal",
    "PatientSARecordID",
    "StoppedBy",
    "MappedBy",
    "MappedDate",
    "RecomendationOverrideReason",
    "IsVariableDose",
    "IsDoseChange",
    "ReferenceMedication",
    "MIMSCODE",
    "PermanentAddressLatitude",
    "PermanentAddressLongitude",
    "PracticeLocationID",
    "LocationName",
    "PrescriptionPrintDate",
    "PrescriptionNo",
    "SubstanceName",
    "PerOrgId",
    "LoadedDateTime",
  ],
  diagnoses: [
    "DiagnosisID",
    "AppointmentID",
    "PatientID",
    "DiseaseID",
    "Disease",
    "DiagnosisDate",
    "DiagnosisByID",
    "DiagnosisBy",
    "Summary",
    "IsLongTerm",
    "AddtoProblem",
    "IsHighlighted",
    "SequenceNo",
    "IsActive",
    "IsDeleted",
    "InsertedByID",
    "InsertedBy",
    "UpdatedByID",
    "UpdatedBy",
    "InsertedAt",
    "UpdatedAt",
    "IsConfidential",
    "DiagnosisTypeID",
    "DiagnosisType",
    "ClassificationRecord",
    "MedTechID",
    "MedTechReadCode",
    "MedTechReadTerm",
    "IsMapped",
    "PracticeID",
    "Practice",
    "OnSetDate",
    "UserLoggingID",
    "LoggingUserName",
    "RecallID",
    "Recall",
    "ExclusionStartDate",
    "ExclusionEndDate",
    "ShowOnPortal",
    "ExtAppointmentID",
    "PatientMEDTechID",
    "PermanentAddressLatitude",
    "PermanentAddressLongitude",
    "PracticeLocationID",
    "LocationName",
    "SNOMEDID",
    "SnomedTerm",
    "CONCEPTID",
    "PerOrgId",
    "LoadedDateTime",
  ],
  inbox: [
    "InboxFolderItemID",
    "FolderID",
    "FolderName",
    "IsSystemFolder",
    "OrderNo",
    "ItemTypeID",
    "ItemType",
    "PatientID",
    "ProviderID",
    "PracticeID",
    "PatientName",
    "Provider",
    "PracticeName",
    "FromOrgID",
    "FromOrganizationName",
    "AssignToID",
    "AssignTo",
    "ResultDate",
    "MessageSubjectID",
    "MessageSubject",
    "Comments",
    "MarkAsRead",
    "IsConfidential",
    "ShowonPortal",
    "IsReviewed",
    "ShowOnTimeLine",
    "IsActive",
    "IsDeleted",
    "InsertedByID",
    "InsertedBy",
    "UpdatedByID",
    "UpdatedBy",
    "InsertedAt",
    "UpdatedAt",
    "MedTechID",
    "DMSID",
    "IsRepeatRX",
    "IsRepliedRx",
    "ExternalRef",
    "ABNORMResult",
    "IsDeactivated",
    "FolderGroup",
    "DocumentCode",
    "IsGP2GP",
    "InformatID",
    "Informat",
    "PermanentAddressLatitude",
    "PermanentAddressLongitude",
    "FiledAt",
    "PerOrgId",
    "LoadedDateTime",
  ],
  inbox_detail: [
    "InBoxFolderItemInLineID",
    "InboxFolderItemID",
    "PatientID",
    "PracticeID",
    "PracticeName",
    "Prompt",
    "Result",
    "AbNorm",
    "Unit",
    "ResultCode",
    "ReferenceRanges",
    "LineNumber",
    "InsertedAt",
    "IsConfidential",
    "ShowonPortal",
    "IsActive",
    "IsDeleted",
    "PerOrgId",
    "LoadedDateTime",
  ],
  invoice_detail: [
    "InvoiceDetailID",
    "InvoiceTransactionID",
    "MasterServiceSubServiceID",
    "AppointmentServiceID",
    "Comments",
    "Quantity",
    "ClaimAmount",
    "CoPayment",
    "GrossClaimAmount",
    "GrossCoPayment",
    "IsBillingAmount",
    "FunderID",
    "FunderName",
    "ContractServiceID",
    "ContractServiceName",
    "IsFunded",
    "SubmissionStatus",
    "CaseNo",
    "SequenceNo",
    "BillingClaimStatusID",
    "MasterServiceName",
    "MasterServiceCode",
    "MasterServiceDescription",
    "ServiceName",
    "Description",
    "Code",
    "FeeCode",
    "ServiceCode",
    "SubServiceDescription",
    "Duration",
    "IsCommonService",
    "ServiceCodeForClaim",
    "IsActive",
    "IsDeleted",
    "InsertedByID",
    "UpdatedByID",
    "InsertedBy",
    "UpdatedBy",
    "InsertedAt",
    "UpdatedAt",
    "UserLoggingID",
    "LoggingUserName",
    "BillingRefID",
    "BillingReferralID",
    "PermanentAddressLatitude",
    "PermanentAddressLongitude",
    "PracticeID",
    "PerOrgID",
    "LoadedDateTime",
  ],
  invoices: [
    "InvoiceTransactionID",
    "PatientID",
    "ACDATE",
    "MedtechID",
    "PaymentMode",
    "TotalAmount",
    "UnpaidAmount",
    "ClaimNotes",
    "Description",
    "IncomeProvider",
    "InvoicePaymentNo",
    "Provider",
    "DomicileCode",
    "InsertedAt",
    "InsertedBy",
    "UpdatedAt",
    "UpdatedBy",
    "IsActive",
    "TransactionType",
    "ProviderID",
    "PracticeID",
    "PermanentAddressLatitude",
    "PermanentAddressLongitude",
    "PracticeLocationID",
    "LocationName",
    "Notes",
    "PerOrgId",
    "LoadedDateTime",
  ],
  measurements: [
    "PatientID",
    "ScreaningID",
    "AppointmentID",
    "ScreeningDate",
    "SCNCODE",
    "ScreeningType",
    "ScreeningGroup",
    "Outcome",
    "OutcomeDescription",
    "Notes",
    "IsActive",
    "UpdatedByID",
    "UpdatedBy",
    "UpdatedAt",
    "InsertedByID",
    "InsertedBy",
    "InsertedAt",
    "PatientMedTechID",
    "Practice",
    "PracticeID",
    "ProviderID",
    "ProviderCode",
    "ProviderName",
    "HBAIC",
    "IsDeleted",
    "CarePlanID",
    "CarePlaneName",
    "IsConfidential",
    "IsGP2GP",
    "IsPatientPortal",
    "IsShowonTimeLine",
    "MedTechID",
    "ScreeningSourceTypeID",
    "ServiceTemplateID",
    "ServiceTemplateName",
    "UserLoggingID",
    "LoggingUserName",
    "Field1",
    "Field2",
    "Field3",
    "Field4",
    "Field5",
    "Field6",
    "Field7",
    "Field8",
    "Field9",
    "Field10",
    "Field11",
    "Field12",
    "Field13",
    "Field14",
    "Field15",
    "Field16",
    "Field17",
    "Field18",
    "Field19",
    "Field20",
    "Field21",
    "Field22",
    "Field23",
    "Field24",
    "Field25",
    "Field26",
    "Field27",
    "Field28",
    "Field29",
    "Field30",
    "Field31",
    "Field32",
    "Field33",
    "Field34",
    "Field35",
    "Field36",
    "Field37",
    "Field38",
    "Field39",
    "Field40",
    "Field41",
    "Field42",
    "Field43",
    "Field44",
    "Field45",
    "Field46",
    "Field47",
    "Field48",
    "Field49",
    "Field50",
    "PermanentAddressLatitude",
    "PermanentAddressLongitude",
    "PracticeLocationID",
    "LocationName",
    "Field51",
    "Field52",
    "Field53",
    "Field54",
    "Field55",
    "Field56",
    "Field57",
    "Field58",
    "Field59",
    "Field60",
    "Field61",
    "Field62",
    "Field63",
    "Field64",
    "Field65",
    "Field66",
    "Field67",
    "Field68",
    "Field69",
    "Field70",
    "Field71",
    "Field72",
    "Field73",
    "Field74",
    "Field75",
    "Field76",
    "Field77",
    "Field78",
    "Field79",
    "Field80",
    "Field81",
    "Field82",
    "Field83",
    "Field84",
    "Field85",
    "Field86",
    "Field87",
    "Field88",
    "Field89",
    "Field90",
    "Field91",
    "Field92",
    "Field93",
    "Field94",
    "Field95",
    "Field96",
    "Field97",
    "Field98",
    "Field99",
    "Field100",
    "Score",
    "ScreeningTypeID",
    "PerOrgId",
    "LoadedDateTime",
  ],
  next_of_kin: [
    "NexttoKinID",
    "PatientID",
    "NOKProfileID",
    "NHINumber",
    "Name",
    "FullAddress",
    "CellNumber",
    "DayPhone",
    "NightPhone",
    "IsEmergency",
    "RelationshipTypeID",
    "RelationshipType",
    "IsActive",
    "IsDeleted",
    "InsertedByID",
    "InsertedBy",
    "UpdatedByID",
    "UpdatedBy",
    "InsertedAt",
    "UpdatedAt",
    "UserLoggingID",
    "LoggingUserName",
    "IsGP2GP",
    "PermanentAddressLatitude",
    "PermanentAddressLongitude",
    "PracticeID",
    "PerOrgId",
    "LoadedDateTime",
  ],
  patient_alerts: [
    "PatientAlertID",
    "PatientID",
    "TypeID",
    "Type",
    "AlertID",
    "Alert",
    "SeverityID",
    "Severity",
    "AlertValue",
    "LastUpdatedDate",
    "EffectiveDate",
    "ExpiryDate",
    "Note",
    "IsActive",
    "IsDeleted",
    "InsertedByID",
    "InsertedBy",
    "UpdatedByID",
    "UpdatedBy",
    "InsertedAt",
    "UpdatedAt",
    "MedTechID",
    "UserLoggingID",
    "LoggingUserName",
    "IsGP2GP",
    "PermanentAddressLatitude",
    "PermanentAddressLongitude",
    "AlertState",
    "PracticeID",
    "ProviderID",
    "PerOrgId",
    "LoadedDateTime",
  ],
  recalls: [
    "ReCallID",
    "PatientID",
    "ReCallDate",
    "IsContacted",
    "Notes",
    "PatientMedTechID",
    "RecallReason",
    "ScreeningType",
    "Code",
    "Vaccine",
    "VaccineGroup",
    "ReCallGroup",
    "InsertedAt",
    "Insertedby",
    "UpdatedAt",
    "UpdatedBy",
    "IsActive",
    "Practice",
    "PracticeID",
    "ProviderID",
    "IsDeleted",
    "PermanentAddressLatitude",
    "PermanentAddressLongitude",
    "IsConfidential",
    "ShowonPatientPortal",
    "IsCanceled",
    "ReCallAttempts",
    "SCNCode",
    "PerOrgId",
    "LoadedDateTime",
  ],
};

/**
 * Converts a column name from PascalCase to camelCase.
 * Properly handles acronyms by treating sequences of 2+ consecutive
 * uppercase letters as single words to be lowercased.
 * Also corrects casing for common English words (of, to, for, etc.).
 * @param columnName - The column name to convert (e.g., "NHINumber", "IsNHIValidate")
 * @returns The camelCase version of the input
 * @throws {Error} If input is not a string
 */
function convertToCamelCase(columnName: string): string {
  // Common English words that should be properly capitalized in camelCase
  const commonWords = new Set([
    "of",
    "to",
    "for",
    "in",
    "on",
    "at",
    "by",
    "with",
    "from",
    "into",
    "onto",
    "upon",
    "after",
    "before",
    "during",
    "since",
    "until",
    "through",
    "across",
    "against",
    "along",
    "among",
    "around",
    "behind",
    "below",
    "beneath",
    "beside",
    "between",
    "beyond",
    "inside",
    "outside",
    "under",
    "above",
    "over",
    "within",
    "without",
    "about",
    "above",
    "across",
    "after",
    "against",
    "along",
    "among",
    "around",
    "before",
    "behind",
    "below",
    "beneath",
    "beside",
    "between",
    "beyond",
    "during",
    "except",
    "inside",
    "outside",
    "since",
    "through",
    "throughout",
    "toward",
    "towards",
    "under",
    "underneath",
    "until",
    "unto",
    "upon",
    "with",
    "within",
    "without",
  ]);

  // Input validation
  if (typeof columnName !== "string") {
    throw new Error("Input must be a string");
  }

  if (columnName.length === 0) {
    return columnName;
  }

  // Remove brackets if present (legacy support)
  const cleanName = columnName.replace(/[\[\]]/g, "");

  if (cleanName.length === 0) {
    return cleanName;
  }

  // Split into tokens: acronyms (2+ uppercase), words (mixed case), lowercase words, and numbers
  const tokens =
    cleanName.match(
      /([A-Z]+(?=[A-Z][a-z]|[^A-Za-z]|$)|[A-Z][a-z]*|[a-z]+|[0-9]+)/g
    ) || [];

  if (tokens.length === 0) {
    return cleanName.toLowerCase();
  }

  // Process each token
  const processed = tokens.map((token, index) => {
    let result: string;

    if (token.length >= 2 && /^[A-Z]+$/.test(token)) {
      // Acronym: 2+ consecutive uppercase letters â†’ lowercase
      result = token.toLowerCase();
    } else if (/^[0-9]+$/.test(token)) {
      // Number: keep as-is
      result = token;
    } else {
      // Word: convert to PascalCase, with special handling for common words
      const lowerToken = token.toLowerCase();
      if (commonWords.has(lowerToken)) {
        // Common English word: ensure proper PascalCase
        result = lowerToken.charAt(0).toUpperCase() + lowerToken.slice(1);
      } else {
        result = token.charAt(0).toUpperCase() + token.slice(1).toLowerCase();
      }
    }

    // For tokens after the first, ensure they start with uppercase (except numbers)
    if (index > 0 && result.length > 0 && !/^[0-9]/.test(result)) {
      result = result.charAt(0).toUpperCase() + result.slice(1);
    }

    return result;
  });

  // Join tokens and ensure first character is lowercase
  const result = processed.join("");
  return result.length > 0
    ? result.charAt(0).toLowerCase() + result.slice(1)
    : result;
}

/**
 * Converts a column name from PascalCase to snake_case.
 * Properly handles acronyms by treating sequences of 2+ consecutive
 * uppercase letters as single words to be lowercased.
 * Also properly separates common English words (of, to, for, etc.).
 * @param columnName - The column name to convert (e.g., "NHINumber", "IsNHIValidate")
 * @returns The snake_case version of the input
 * @throws {Error} If input is not a string
 */
function convertToSnakeCase(columnName: string): string {
  // Input validation
  if (typeof columnName !== "string") {
    throw new Error("Input must be a string");
  }

  if (columnName.length === 0) {
    return columnName;
  }

  // Remove brackets if present (legacy support)
  const cleanName = columnName.replace(/[\[\]]/g, "");

  if (cleanName.length === 0) {
    return cleanName;
  }

  // Split into tokens: acronyms (2+ uppercase), words (mixed case), lowercase words, and numbers
  const tokens =
    cleanName.match(
      /([A-Z]+(?=[A-Z][a-z]|[^A-Za-z]|$)|[A-Z][a-z]*|[a-z]+|[0-9]+)/g
    ) || [];

  if (tokens.length === 0) {
    return cleanName.toLowerCase();
  }

  // Process each token: acronyms, words, and numbers
  const processed = tokens.map((token) => {
    if (token.length >= 2 && /^[A-Z]+$/.test(token)) {
      // Acronym: 2+ consecutive uppercase letters â†’ lowercase
      return token.toLowerCase();
    } else if (/^[0-9]+$/.test(token)) {
      // Number: keep as-is
      return token;
    } else {
      // Word: convert to lowercase
      return token.toLowerCase();
    }
  });

  // Join with underscores
  return processed.join("_");
}

function generateSchemaFile(entityName: string, columns: string[]): string {
  const snakeCaseName = entityName.replace(/-/g, "_"); // Convert kebab-case to snake_case for table name
  const tableName = `raw.${snakeCaseName}`;
  const className =
    entityName.charAt(0).toLowerCase() +
    entityName.slice(1).replace(/[-_]/g, "") +
    "Raw";

  const columnDefinitions = columns
    .map((col) => {
      const fieldName = convertToCamelCase(col); // camelCase for field name
      const dbColumnName = convertToSnakeCase(col); // snake_case for DB column
      return `  ${fieldName}: text("${dbColumnName}"),`;
    })
    .join("\n");

  return `import {
  text,
  timestamp,
  uuid,
  boolean,
  integer,
  date,
  check,
  uniqueIndex,
  foreignKey,
} from "drizzle-orm/pg-core";
import { createTable } from "../../utils/create-table";
import { loadRunFiles } from "../etl/audit";

export const ${className} = createTable("${tableName}", {
  // Source columns as text (all fields from ${entityName} extract)
${columnDefinitions}

  // Foreign key to load_run_files for lineage data
  loadRunFileId: integer("load_run_file_id").notNull(),
});

// Foreign key constraint to etl.load_run_files
export const fk${className}LoadRunFile = foreignKey({
  columns: [${className}.loadRunFileId],
  foreignColumns: [loadRunFiles.loadRunFileId],
  name: "fk_${entityName}_load_run_file",
});
`;
}

async function main() {
  console.log("ðŸš€ Generating missing schema files...");
  console.log("=".repeat(50));

  const schemaDir = path.join(__dirname, "../../../db/schema/raw");
  const results = {
    generated: [] as string[],
    skipped: [] as string[],
    errors: [] as string[],
  };

  // Create schema directory if it doesn't exist
  try {
    fs.mkdirSync(schemaDir, { recursive: true });
  } catch (error) {
    // Directory might already exist
  }

  // Convert entity names to kebab-case for filenames
  const entityNameMappings: Record<string, string> = {
    appointment_medications: "appointment-medications",
    inbox_detail: "inbox-detail",
    invoice_detail: "invoice-detail",
    next_of_kin: "next-of-kin",
    patient_alerts: "patient-alerts",
    practice_info: "practice-info",
    "practice-info": "practice-info", // Handle kebab-case keys
  };

  // Generate schema files for missing entities
  for (const [entityName, columns] of Object.entries(entityColumns)) {
    const kebabCaseName = entityNameMappings[entityName] || entityName;
    try {
      console.log(`\nðŸ“ Processing ${entityName}...`);

      const schemaPath = path.join(schemaDir, `${kebabCaseName}.ts`);

      if (fs.existsSync(schemaPath)) {
        console.log(`âš ï¸  Schema file already exists: ${schemaPath}`);
        results.skipped.push(entityName);
        continue;
      }

      const schemaContent = generateSchemaFile(kebabCaseName, columns);
      fs.writeFileSync(schemaPath, schemaContent);

      results.generated.push(entityName);
      console.log(`âœ… Generated: ${schemaPath}`);
    } catch (error) {
      console.error(`âŒ Error processing ${entityName}:`, error);
      results.errors.push(
        `${entityName}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  // Summary
  console.log("\n" + "=".repeat(50));
  console.log("ðŸ“Š Schema Generation Summary:");
  console.log(`âœ… Generated: ${results.generated.length} schema files`);
  console.log(`âš ï¸  Skipped: ${results.skipped.length} schema files`);
  console.log(`âŒ Errors: ${results.errors.length} schema files`);

  if (results.generated.length > 0) {
    console.log("\nðŸ“‹ Generated schema files:");
    results.generated.forEach((entity) => {
      console.log(`  - ${entity}.ts`);
    });
  }

  if (results.skipped.length > 0) {
    console.log("\nâš ï¸  Skipped (already exist):");
    results.skipped.forEach((entity) => console.log(`  - ${entity}.ts`));
  }

  if (results.errors.length > 0) {
    console.log("\nâŒ Errors:");
    results.errors.forEach((error) => console.log(`  - ${error}`));
  }

  console.log("\nNext steps:");
  console.log("1. Review generated schema files");
  console.log("2. Run generate-all-handlers.ts again to create handlers");
  console.log("3. Add custom validation rules to handlers");
  console.log("4. Update ExtractHandlerFactory");
}

// Run the generator
main().catch(console.error);
